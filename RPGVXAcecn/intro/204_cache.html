<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="en">
<head>


  
  <meta http-equiv="Content-Type" content="text/html; charset=GB2312">


  
  <meta http-equiv="Content-Style-Type" content="text/css">



  
  
  <title>Cache 模块</title>
  <link href="../style.css" type="text/css" rel="stylesheet">
</head>


<body>



<h1>Cache 模块</h1>


<ul>


  <li><a href="#what">什么是Cache</a></li>


  <li><a href="#use">Cache的使用方法</a></li>


  <li><a href="#detail">细节</a></li>


  <li><a href="#@cache">@cache</a></li>


  <li><a href="#bitmap">bitmap生成</a></li>


</ul>



<p>Cache 是高速读取图像文件的模块。</p>




<h2><a name="what">什么是Cache</a></h2>


<p>在基础篇里<a href="109_graphics.html">显示图像</a>的时候，使用了<a href="../rgss/gc_bitmap.html">Bitmap</a>这个类 </p>


<pre>skeleton.bitmap = Bitmap.new("Graphics/Battlers/Skeleton")<br></pre>


<p>就像这样Bitmap 类的实变量生成的时候，作为参数可以读取指定图像文件。</p>


<p>可是每次读取图像的效率很低。能够保存 Bitmap 对像这一功能正是 Cache 模块的作用。</p>


<p>Cache 是「缓存」的，这是这个模块命名的由来。</p>




<h2><a name="use">Cache的使用方法</a></h2>


<p>比起说Cache 模块件内部是如何定义的，还是说怎么使用比较重要。</p>


<p>使用方法如下 (注意: Cache 模块的定义没完成的 TEST 项里不能使用)。</p>


<pre>skeleton.bitmap = Cache.battler("Skeleton", 0)<br></pre>


<p>这个脚本是从战斗图文件里取得 "Skeleton"这个位图内容的。不指定Graphics/Battlers/"文件夹名也没有问题。</p>


<p>第2个参数的「0」，表示色相变化值。值的范围从 0～360 ，仅仅使用在动画图像和战斗图像里。</p>


<p>与各种素材文件夹对应的方法参考下面</p>


<table border="1" cellpadding="2" cellspacing="0">


  <tbody>

    <tr>


 <th>方法名</th>


 <th>参数</th>


 <th>文件夹</th>


    </tr>

    <tr>


 <td>Cache.animation</td>


 <td>文件名，色相</td>


 <td>Graphics/Animations/</td>


    </tr>

    <tr>


 <td>Cache.battler</td>


 <td>文件名，色相</td>


 <td>Graphics/Battlers/</td>


    </tr>

    <tr>


 <td>Cache.character</td>


 <td>文件名</td>


 <td>Graphics/Characters/</td>


    </tr>

    <tr>


 <td>Cache.face</td>


 <td>文件名</td>


 <td>Graphics/Faces/</td>


    </tr>

    <tr>


 <td>Cache.parallax</td>


 <td>文件名</td>


 <td>Graphics/Parallaxes/</td>


    </tr>

    <tr>


 <td>Cache.picture</td>


 <td>文件名</td>


 <td>Graphics/Pictures/</td>


    </tr>

    <tr>


 <td>Cache.system</td>


 <td>文件名</td>


 <td>Graphics/System/</td>


    </tr>

  
  </tbody>
</table>


<p>与Sound 模块一样，即使是不存在的文件名也不会产生错误。只是返回32&times;32 大小的空位图而已。之所以不是1&times;1 ，是因为要和RGSS 内部兼容。

</p>

<h2><a name="detail">细节</a></h2>
<p>为了能对Cache有更加深刻的了解，我们来看看实际上是如何运作的。<br>
<br>
首先从 Cache.battler 这个方法定义。</p>

<pre> def self.battler(filename, hue)<br> load_bitmap("Graphics/Battlers/", filename, hue)<br> end<br></pre>

<p>很简单把。只是将参战者战斗图作为一般参数进行追加，再将名为load_bitmap的另一方法呼叫出来。那么，让我们来看看需要呼叫的load_bitmap方法在哪里。</p>

<pre> def self.load_bitmap(folder_name, filename, hue = 0)<br> @cache = {} if @cache == nil<br> path = folder_name + filename<br> if not @cache.include?(path) or @cache[path].disposed?<br> if filename.empty?<br> @cache[path] = Bitmap.new( ,  )<br> else<br> @cache[path] = Bitmap.new(path)<br> end<br> end<br> if hue == 0<br> return @cache[path]<br> else<br> key = [path, hue]<br> if not @cache.include?(key) or @cache[key].disposed?<br> @cache[key] = @cache[path].clone<br> @cache[key].hue_change(hue)<br> end<br> return @cache[key]<br> end<br> end<br></pre>

<p>需要解读出这个是非常困难的。让我们来细细解读每一个小段落。</p>

<pre> def self.load_bitmap(folder_name, filename, hue = 0)<br></pre>

<p>最上面的一行是就是方法模块的定义。是将色相和图档名作为一般参数从而来取得定义的。被色相 (hue)所指定的“0”是默认参数。这和<a href="107_function.html">函数</a>的情况是完全一样的。</p>


<h2><a name="@cache">@cache</a></h2>

<p>第二行开始就比较麻烦了。</p>

<pre> @cache = {} if @cache == nil<br></pre>

<p>首先是关于语法，这个在基础篇（<a href="105_branch.html">条件分岐</a>）的最后部分解释过，是“修饰子”形式的条件分歧。其意思与下文相同。</p>

<pre> if @cache == nil<br> @cache = {}<br> end<br></pre>

<p>这个是普通的编写方式，为了能够简洁了然地编程而使用了if修饰子。</p>

<p>{} 这个记号是什么还记得吗？　这个就是空<a href="111_hash.html">HASH</a>的做成方法。总结起来的意思就是@cache这个变量的值为 nil 的时候，将空的HASH对象生成并代入其中。实例变量，通常来说是被类定义为通常的方法来使用的，但这里是在方法模块之中。在这种情况下，实例变量就可以被解释成属于 Cache 模块的变量。</p>

<p>还有一点，在基础编的开头解说<a href="103_variable.html">变量</a>的时候，曾经说明过不可以引用一个没有被代入过一次的变量。</p>

<pre>p zzz # ERROR!!<br></pre>
事实上，这是只在局部变量的情况下适用的规则。在实例变量和总体变量的情况下，即使引用一个没有被代入过一次的变量也不会有报错提示，而是会得到 nil 这一提示。利用这一点，我们就可以判断 @cache 变量是否被初始化了。
<h2><a name="bitmap">bitmap生成</a><a name="bitmap"></a></h2>

<p>接下来是第三行。</p>

<pre> path = folder_name + filename<br></pre>

<p>这个很简单。就是对<a href="104_string.html">字符串</a>进行相加。比方说目录名folder_name为"Graphics/Battlers/"，文件名filename为"Skeleton"的时候，将它们连接在一起的"Graphics/Battlers/Skeleton"这一文字列就会被代入局部变量path中。</p>

<p>让我们开看第四行。</p>

<pre> if not @cache.include?(path) or @cache[path].disposed?<br></pre>

<p>这是一个十分复杂的条件分歧。在这里所判断的条件为，在 @cache 所指的HASH对象中，path这一字符串内部并不含有key，并且是在这个Bitmap没有被释放的情况下。对于include?与disposed?这些方法来说，请参考<a href="../rgss/sc_hash.html">Hash</a>和<a href="../rgss/gc_bitmap.html">Bitmap</a>。</p>

<p>以下是第五行。</p>

<pre> if filename.empty?<br> @cache[path] = Bitmap.new( ,  )<br> else<br> @cache[path] = Bitmap.new(path)<br> end<br></pre>

<p>正如RGSS参考中所写的那样，<a href="../rgss/gc_bitmap.html#new">Bitmap.new</a>有两种被调出的方式。将一段字符串以一般参数的定义提交时，会将其认知为图片文件的路径名来进行读取。将两个整数以一般参数的方式提交时，会将其认成Bitmap的尺寸规格，做成一个空的Bitmap。在这里，如果被指定的内容不是空的，则采用前者的调用方式，是空的的话就会按照后者的方式被调用。</p>

<p>到这里为止，保证了在@cache[path]之中收纳了位图。接下来会进行对色相变化的对应处理，但个人认为这只是非常繁杂的过程并没有可学之处，所以就略过不提。</p>


<h6></h6>
</body>
<html>