<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="en">
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=GB2312">

  <meta http-equiv="Content-Style-Type" content="text/css">


  <title>定义类</title>
  <link href="style.css" type="text/css" rel="stylesheet">


</head>


<body>


<h1>定义类</h1>

<ul>

  <li><a href="#define">类的定义</a></li>

  <li><a href="#method">方法的定义</a></li>

  <li><a href="#instance">实变量</a></li>

  <li><a href="#accessor">アクセサの定x</a></li>

  <li><a href="#initialize">对像初始化</a></li>

  <li><a href="#override">方法的重载</a></li>

</ul>


<p>基础篇的最后，让我们来学习定义新类的方法。</p>



<h2><a name="define">类的定义</a></h2>

<p>直到今天，我们都是一直在使用 <a href="../rgss/sc_string.html">String</a> 
类、<a href="../rgss/sc_array.html">Array</a> 类或者
<a href="../rgss/gc_sprite.html">Sprite</a> 类等这些系统内部类的方法来进行学习。
实际上如果想使用类，也可以自己定义。所谓「建立类」几乎和「程序设计」是一个意思。
其实预置脚本中，除外最后一个 Main 组其余的全部都是类定义。</p>

<p>比如新定义一个 Person 类，可以如下操作。</p>

<pre>class Person<br>end<br></pre>

<p>定义类的话这样就行了。
但现在只是个「什么都没有的类」，让我们再来进行以下操作。</p>

<pre>alex = Person.new<br></pre>

<p>这样就作成一个 Person 类的实例。</p>

<p>想要指定超类也很简单。
比如，定义继承于超类 Monkey 类的  Person 类可以如下操作。</p>

<pre>class Person &lt; Monkey<br>end<br></pre>



<h2><a name="method">方法的定义</a></h2>

<p>方法的定义，和定义普通函数的情况相同。
如果在类定义当中加上 def ～ end 的话，就会自动成为该类的方法。</p>

<pre>class Person<br>  def hello<br>    print "您好"<br>  end<br>end<br></pre>

<p>这样，就定义了调用后会显示「您好」字符串的 hello 方法。再进行如下操作。</p>
<p>
</p>
<pre>alex = Person.new<br>alex.hello                  # =&gt; 您好<br></pre>

<p>这样就能调用 hello 方法了。</p>

<p>なお、ここではしくは解hしませんが、Ruby でv数と呼んでいるもの
は「どこからでも呼び出せる形のメソッド」に相`ありません。</p>

<h2><a name="instance">实变量</a></h2>

<p>属于个体对象的变量称为<strong>实变量</strong>。
名称以 @ 开头的变量，自动作为实变量使用。
局部变量只有在 def ～ end 等结构内部使用时才有效，
然而使用实变量的话，只要其对像存在，变量的值就会被保存。
实变量一般作为对象的属性来使用。</p>

<pre>class Person<br>  def name<br>    return @name<br>  end<br>  def name=(name)<br>    @name = name<br>  end<br>  def hello<br>    print "我是" + @name<br>  end<br>end<br><br>alex = Person.new<br>alex.name = "阿莱库斯"<br>alex.hello                  # =&gt; 我是阿莱库斯<br></pre>

<p>上面的示例是先准备 @name 实变量，
使用 name、name= 方法把对像附加上 @name 实变量作为属性。
像这样的方法称为<strong>附加属性</strong>。
附加属性也能更简单的像下面那样编写。</p>

<pre>  attr_accessor :name<br></pre>

<p>这样编写是，自动定义与 : 符号右侧名称相同的实变量对应属性的取得和批注方法。
上例中是生成 @name 实变量并附加成为属性。总之，</p>

<pre>  def name<br>    return @name<br>  end<br>  def name=(name)<br>    @name = name<br>  end<br></pre>

<p>是与上面相同的意思。</p>

<p>在预置脚本中 attr_accessor 应用得很多。
但在只定义属性的取得方法的情况下，
一般使用 attr_reader 代替 attr_accessor。</p>
<p>この例では @name というインスタンス涫を用意し、name、name= という
メソッドを使ってオブジェクトの外からアクセスできるようにしています。
なお、末尾に = 号のついたメソッドは、foo.name = bar
の形式で呼び出されます。</p>
<p>なお、インスタンス涫はグロ`バル涫と同、一度も代入されていない
涫を参照した龊悉膝ē椹`にならずに nil が返されます。</p>

<p><font size="7"><b>上面一段看情况删减排版</b></font></p>
<h2><a name="accessor">アクセサの定x</a></h2>
<p>name、name= のように、オブジェクト内部のデ`タをiみきするための
メソッドを<strong>アクセサ</strong>と呼びます。</p>
<p>アクセサは、もっとgに次のようにくこともできます。</p>
<pre>
  attr_accessor :name
</pre>
<p>このようにくことで、: の右趣いた名前と同名のインスタンス涫
にしてiみzみおよびきzみができるメソッドが自拥膜硕xされます。
ここでは @name というインスタンス涫にアクセスできるメソッドという
ことになります。つまり、</p>
<pre>
  def name
    return @name
  end

  def name=(name)
    @name = name
  end
</pre>
<p>と同じ意味になります。</p>
<p>プリセットのスクリプトではこの attr_accessor が多用されています。
取得 (iみzみ) のメソッドのみを定xする龊悉稀attr_accessor の
代わりに attr_reader を使用します。</p>


<h2><a name="initialize">对像初始化</a></h2>

<p>生成对像时，把实变量初始化为某个特定的值。
先定义一个名称为 initialize 的方法，
在使用 new 生成新实例时会自动调用该方法。</p>

<pre>class Person<br>  def initialize<br>    @name = "游客"<br>  end<br>end<br></pre>

<p>从第二行开始的 initialize 方法的定义，
表示实变量 @name 的初始值被赋值为字符串 "游客"。
这样，生成新的 Person 对象的时候，会自动以 "游客" 初始化实变量。</p>

<p>initialize 方法中设定有临时参数的情况下，new 会取该参数为初始值。</p>

<pre>class Person<br>  def initialize(name)<br>    @name = name<br>  end<br>end<br><br>alex = Person.new("阿莱库斯")<br></pre>

<p>上述示例中，initialize 方法里设定有临时参数 name，
那么实变量 @name 的初始值就会使用该参数。
参数 name 实际在 Person 类 new 时给予。
最后一行，生成 Person 类对像时指定参数为 "阿莱库斯"，
那么 @name 的初始值也就设定为 "阿莱库斯"。</p>



<h2><a name="override">方法的重载</a></h2>

<p>超类中已定义的方法在子类中再次被定义称为<strong>重载</strong>。
在子类方法中调用超类相同方法的情况下，要使用关键词 <strong>super</strong>。</p>

<pre>class Hahaha<br>  def laugh(x)<br>    return "哈" * x<br>  end<br>end<br><br>class Wahaha &lt; Hahaha<br>  def laugh(x)<br>    return "哇" + super<br>  end<br>end<br><br>man = Wahaha.new<br>p man.laugh(4)      # =&gt; "哇哈哈哈哈"<br></pre>

<p>上述示例是，对新建实例调用 Wahaha 类的 laugh 方法，
其中 super 能调用其超类 Hahaha 类的 laugh 方法。
那么，最后一行调用 laugh 方法可以理解为 "哇" + "哈" * 4，
于是输出结果就为 "哇哈哈哈哈"。</p>



<h6></h6>

</body>
</html>
