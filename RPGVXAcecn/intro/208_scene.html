<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="en">
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=GB2312">

  <meta http-equiv="Content-Style-Type" content="text/css">


  <title>场景类</title>
  <link href="style.css" type="text/css" rel="stylesheet">

</head>


<body>


<h1>场景类</h1>

<ul>

  <li><a href="#kind">场景类的种类</a></li>

  <li><a href="#mechanism">场景类的结构</a></li>

  <li><a href="#main">Main 组</a></li>

  <li><a href="#ps">写在最后</a></li>

</ul>


<p>负责地图画面、菜单画面等各种画面处理的就是<strong>场景类</strong>。</p>



<h2><a name="kind">场景类的种类</a></h2>

<p>各场景类对应的画面如下所示。</p>

<table border="1" cellpadding="2" cellspacing="0">

  <tbody>
    <tr>

 <th>类</th>

 <th>内容</th>

    </tr>
    <tr>

 <td>Scene_Base</td>

 <td>场景的基本处理</td>

    </tr>
    <tr>

 <td>Scene_Title</td>

 <td>标题画面</td>

    </tr>
    <tr>

 <td>Scene_Map</td>

 <td>地图画面</td>

    </tr>
    <tr>

 <td>Scene_Menu</td>

 <td>菜单画面</td>

    </tr>
    <tr>

 <td>Scene_Item</td>

 <td>物品画面</td>

    </tr>
    <tr>

 <td>Scene_Skill</td>

 <td>特技画面</td>

    </tr>
    <tr>

 <td>Scene_Equip</td>

 <td>装备画面</td>

    </tr>
    <tr>

 <td>Scene_Status</td>

 <td>状态画面</td>

    </tr>
    <tr>

 <td>Scene_File</td>

 <td>存/读档画面</td>

    </tr>
    <tr>

 <td>Scene_End</td>

 <td>游戏结束画面</td>

    </tr>
    <tr>

 <td>Scene_Shop</td>

 <td>商店画面</td>

    </tr>
    <tr>

 <td>Scene_Name</td>

 <td>名称输入画面</td>

    </tr>
    <tr>

 <td>Scene_Debug</td>

 <td>调试画面</td>

    </tr>
    <tr>

 <td>Scene_Battle</td>

 <td>战斗画面</td>

    </tr>
    <tr>

 <td>Scene_Gameover</td>

 <td>游戏结束画面</td>

    </tr>
  </tbody>
</table>



<h2><a name="mechanism">场景类的结构</a></h2>

<p>场景类的实例是保存在 $scene 名称的全局变量中。
这个变量只要值不是 nil 就能调用 main 名称的方法，是继续游戏运行的结构。
典型的场景类的构架如下所示。</p>

<pre>
  def main
    start                         # 开始处理
    perform_transition            # 开始转换
    post_start                    # 开始后处理
    Input.update                  # 更新输入信息
    loop do
      Graphics.update             # 更新游戏画面
      Input.update                # 更新输入信息
      update                      # 更新画面
      break if $scene != self     # 画面切换循环中断
    end
    Graphics.update
    pre_terminate                 # 结束前处理
    Graphics.freeze               # 准备转换
    terminate                     # 结束处理
  end
</pre>

<p>start、update、terminate等，是场景类定义的方法。Scene_Base 类里面虽然几乎没有什么内容，在Scene_Title，Scene_Map等子类中进行再定义就构成了各自画面里执行开始处理，结束处理等命令的场景
</p>

<p>if $scene != self 是「如果全局变量 $scene 指定的对象不是自己的话」的意思，
即「切换到其它画面的情况」（self 是表示自身对象的伪变量）。
另外，Input.update 是更新游戏手柄和键盘输入信息的方法。
输入关联的处理请参照 <a href="../rgss/gm_input.html">Input</a> 模块的说明。</p>

<p>还有，基础篇中曾介绍过的下面这个形式是 RGSS 游戏运行的基本结构。
Scene_Base 类的 main 方法那样复杂的处理，都是在这个形式上发展而来的。</p>

<pre>loop do<br>  Graphics.update<br>end<br></pre>



<h2><a name="main">Main 组</a></h2>

<p>终于到最后的组了。到现在为止上面的组全都是关于类的定义，
实际上，可以认为真正脚本的运行是从这里开始的。Main 组除去注释只剩下下面的这 10 行。</p>

<pre>

Font.default_name = ["SimHei", "黑体", "DFKai-SB", "丝w", "Verdana", "Arial Unicode MS"]
begin
  Graphics.freeze
  $scene = Scene_Title.new
  $scene.main while $scene != nil
  Graphics.transition(30)
rescue Errno::ENOENT
  filename = $!.message.sub("没有这样的文件或目录――", "")
  print("无法找到文件：#{filename}.")
end

</pre>

<p>首先，用Font.default_name定义游戏字体，从等号后面罗列的字体中选择第一个可用的字体作为游戏默认显示的字体。</p>
<p>需要说明的是，适用于Windows操作系统的每一款字体都有其国际通用的英文名称（如上例，SimHei是简体中文Windows中的黑体的英文名，使用该英文名能够在繁体中文Windows中运行游戏时正常显示黑体；同样，DFKai-SB是繁体中文Windows中的丝w的英文名，使用该英文名能够在简体中文Windows中运行游戏时正常显示丝w。），所以建议用英文名称定义字体以方便自己做的游戏跨语言平台正常显示。</p>
<p>另外，ARIAL国际标准编码字体(Arial Unicode MS)和采用微软ClearType(TM)技术显示的字体[如简体Windows的微软雅黑(Microsoft YaHei)和繁体Windows的微软正黑体(Microsoft JhengHei)等]在游戏中显示的时候会显得字号偏小，使用时需要注意。</p>
<p>此外，由于ARIAL国际标准编码字体(Arial Unicode MS)可以显示所有UNICODE编码的字符，所以放在最后一棒以备用。</p>
<p>-----------------------------------------------------</p>

<p>begin ～ rescue ～ end 是异常处理的句法。这里，
是脚本的运行中如果发生「找不到文件」的异常情况时指定转移执行 rescue 以下的处理。
即显示「找不到文件 XXX」的错误信息后结束程序。
异常处理在预置脚本中也可以不使用，所以没有记住其使用方法也不要紧。</p>
<p>-----------------------------------------------------</p>
<p>Graphics.freeze 和 Graphics.transition 在先前就已介绍过了。
其中最先是进行「准备渐变」，准备从黑幕的状态逐渐显示到标题画面。
最后的 Graphics.transition 是相反的过程又渐变到黑幕状态结束。</p>
<p>-----------------------------------------------------</p>
<p>还剩下 2 行。先是生成负责标题画面处理的 Scene_Title 类的实例，
设定全局变量 $scene。然后和前面讲过的那样 $scene 变量只要值
不是 nil 就调用 main 名称的方法。</p>



<h2><a name="ps">写在最后</a></h2>

<p>非常感谢大家的关注。本帮助说明文档的第二部分「脚本入门」到这里就结束了。</p>

<p>在迄今为止学习到的知识的基础上，参照本帮助说明文档的第三部分：<a href="../rgss/index.html">「RGSS参考文件」</a>，
应该就能明了地解读预置脚本了。没有必要绝对理解 RGSS 的全部。
有兴趣的话可以到脚本中看看，是不是很自然的产生了要自己写脚本的想法呢？</p><p>几乎是一切皆有可能。使用 RGSS 做什么，一切就看您的了。</p>

<h6></h6>


</body>
</html>
